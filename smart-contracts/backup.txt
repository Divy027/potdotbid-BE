// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";
import "@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol";
import "@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapper.sol";
import "hardhat/console.sol";

contract Token is ERC20, VRFV2PlusWrapperConsumerBase, AutomationCompatible {
    /* Errors */
    error UpkeepNotNeeded();

    address private bondingCurveContract;
    bool private isLaunchedOnDex;

    //
    // Address WRAPPER - hardcoded for Sepolia(change it accordnly)
    address public wrapperAddress = 0x02aae1A04f9828517b3007f83f6181900CaD910c; // change it sepolia : 0x195f15F2d49d693cE265b4fB0fdDbE15b1850Cc1
    uint32 public callbackGasLimit = 100000;
    uint16 public requestConfirmations = 3;
    uint32 public numWords = 1;

    // Selection Parameters
    uint256 public constant MONTHLY_SELECTION_INTERVAL = 30 days;
    uint256 public lastSelectionTime;
    address public selectedAddress;

    // Holder Management
    address[] private holders;
    address[] private eligibleAddressList;
    mapping(address => bool) private holderExists;
    uint256 private constant MINIMUM_BALANCE_THRESHOLD = 1 * 10 ** 18; // Minimum 1 token to be eligible

    // Events
    event AddressSelectedMonthly(
        address indexed selectedAddress,
        uint256 timestamp
    );
    event HolderAdded(address indexed holder);
    event SellAttempted(address indexed seller, uint256 amount);

    modifier onlyBondingCurveContract() {
        require(msg.sender == bondingCurveContract, "Caller is not the owner");
        _; // This is a placeholder that represents the execution of the function
    }

    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _initialSupply,
        address _owner
    ) ERC20(_name, _symbol) VRFV2PlusWrapperConsumerBase(wrapperAddress) {
        console.log("Hi");
        bondingCurveContract = _owner;
        _mint(_owner, _initialSupply);

        // Add initial deployer as first holder
        addHolder(msg.sender);
    }

    // Internal function to add holders
    function addHolder(address _holder) internal {
        if (!holderExists[_holder] && _holder != address(0)) {
            holders.push(_holder);
            holderExists[_holder] = true;
            emit HolderAdded(_holder);
        }
    }

    // Override transfer method with additional checks
    function _update(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // Before DEX launch, allow normal transfers
        if (!isLaunchedOnDex) {
            super._update(from, to, amount);
        } else {
            // Only selected address can sell
            require(from == selectedAddress, "Only selected address can sell");

            // Emit sell attempt event
            emit SellAttempted(from, amount);

            // Perform regular transfer if not selling
            super._update(from, to, amount);
        }

        // Add new holders when receiving tokens
        if (to != address(0) && balanceOf(to) > 0) {
            addHolder(to);
        }
    }

    // Check if upkeep is needed
    function checkUpkeep(
        bytes memory /* checkData */
    )
        public
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp >=
            lastSelectionTime + MONTHLY_SELECTION_INTERVAL);
    }

    // Perform the upkeep
    function performUpkeep(bytes calldata /* performData */) external override {
        (bool upkeepNeeded, ) = checkUpkeep("");
        if (!upkeepNeeded) {
            revert UpkeepNotNeeded();
        }

        // Clear previous eligible addresses
        delete eligibleAddressList;

        // eligible addresses
        for (uint256 i = 0; i < holders.length; i++) {
            address holder = holders[i];
            if (balanceOf(holder) >= MINIMUM_BALANCE_THRESHOLD) {
                eligibleAddressList.push(holder);
            }
        }

        // Ensure at least one eligible address exists
        require(eligibleAddressList.length > 0, "No eligible addresses");

        bytes memory extraArgs = VRFV2PlusClient._argsToBytes(
            VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
        );

        uint256 requestId;
        uint256 reqPrice;
        (requestId, reqPrice) = requestRandomness(
            callbackGasLimit,
            requestConfirmations,
            numWords,
            extraArgs
        );

        lastSelectionTime = block.timestamp;
    }

    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory randomWords
    ) internal override {
        require(eligibleAddressList.length > 0, "No eligible addresses");

        // Select random address
        uint256 randomIndex = randomWords[0] % eligibleAddressList.length;
        selectedAddress = eligibleAddressList[randomIndex];

        // Emit event
        emit AddressSelectedMonthly(selectedAddress, block.timestamp);
    }

    function burn(uint256 _amount) public {
        _burn(msg.sender, _amount);
    }

    function setLaunchedOnDex(bool _isLauched) public onlyBondingCurveContract {
        isLaunchedOnDex = _isLauched;
    }

    // getters
    function getHolders() external view returns (address[] memory) {
        return holders;
    }

    function getEligibleAddresses() external view returns (address[] memory) {
        return eligibleAddressList;
    }

    function getCurrentSelectedAddress() external view returns (address) {
        return selectedAddress;
    }
}
